// Package oprf implements an [RFC 9497]-style Oblivious Pseudorandom Function scheme using Thyrse and Ristretto255.
package oprf

import (
	"crypto/rand"
	"errors"

	"github.com/codahale/thyrse"
	"github.com/gtank/ristretto255"
)

// Blind allows the client to blind a sensitive input. Returns the secret blind scalar and the blinded element to be
// transmitted to the server.
func Blind(domain string, input []byte) (blind *ristretto255.Scalar, blindedElement *ristretto255.Element, err error) {
	// Derive an element from the input.
	p := thyrse.New(domain)
	p.Mix("input", input)
	element, _ := p.Fork("output", []byte("element"), []byte("prf"))
	inputElement, _ := ristretto255.NewIdentityElement().SetUniformBytes(element.Derive("element", nil, 64))
	if inputElement.Equal(ristretto255.NewIdentityElement()) == 1 {
		return nil, nil, errors.New("oprf: input maps to identity element")
	}

	for {
		// Generate a random blind scalar.
		var r [64]byte
		if _, err := rand.Read(r[:]); err != nil {
			panic(err)
		}
		blind, _ = ristretto255.NewScalar().SetUniformBytes(r[:])

		// Ensure the blind is not zero.
		if blind.Equal(ristretto255.NewScalar()) == 0 {
			break
		}
	}

	// Calculate a blinded element.
	blindedElement = ristretto255.NewIdentityElement().ScalarMult(blind, inputElement)

	return blind, blindedElement, nil
}

// BlindEvaluate takes the server's private key and a blinded element and returns an evaluated element to be transmitted
// to the client.
func BlindEvaluate(d *ristretto255.Scalar, blindedElement *ristretto255.Element) (evaluatedElement *ristretto255.Element, err error) {
	if blindedElement.Equal(ristretto255.NewIdentityElement()) == 1 {
		return nil, errors.New("oprf: blinded element is identity")
	}

	return ristretto255.NewIdentityElement().ScalarMult(d, blindedElement), nil
}

// Finalize takes the client's secret input, the blind scalar generated by Blind, the evaluated element returned by
// BlindEvaluate, and the number of bytes to generate, and returns n bytes of PRF output.
func Finalize(domain string, input []byte, blind *ristretto255.Scalar, evaluatedElement *ristretto255.Element, n int) ([]byte, error) {
	if evaluatedElement.Equal(ristretto255.NewIdentityElement()) == 1 {
		return nil, errors.New("oprf: evaluated element is identity")
	}

	// Unblind the element.
	unblindedElement := ristretto255.NewIdentityElement().ScalarMult(ristretto255.NewScalar().Invert(blind), evaluatedElement)
	if unblindedElement.Equal(ristretto255.NewIdentityElement()) == 1 {
		return nil, errors.New("oprf: unblinded element is identity")
	}

	// Derive a bytestring from the input and the unblinded element.
	p := thyrse.New(domain)
	p.Mix("input", input)
	_, prf := p.Fork("output", []byte("element"), []byte("prf"))
	prf.Mix("unblinded-element", unblindedElement.Bytes())
	return prf.Derive("prf", nil, n), nil
}

// Evaluate takes the server's private key, a secret input, and the number of bytes to generate, and returns n bytes of
// PRF output.
//
// Returns the same output as Finalize, but without the blinding step performed by the client.
func Evaluate(domain string, d *ristretto255.Scalar, input []byte, n int) ([]byte, error) {
	// Derive an element from the input.
	p := thyrse.New(domain)
	p.Mix("input", input)
	element, prf := p.Fork("output", []byte("element"), []byte("prf"))

	inputElement, _ := ristretto255.NewIdentityElement().SetUniformBytes(element.Derive("element", nil, 64))
	if inputElement.Equal(ristretto255.NewIdentityElement()) == 1 {
		return nil, errors.New("oprf: input maps to identity element")
	}

	// Evaluate the element ourselves.
	evaluatedElement := ristretto255.NewIdentityElement().ScalarMult(d, inputElement)
	if evaluatedElement.Equal(ristretto255.NewIdentityElement()) == 1 {
		return nil, errors.New("oprf: evaluated element is identity")
	}

	// Derive a bytestring from the input and the unblinded element.
	prf.Mix("unblinded-element", evaluatedElement.Bytes())
	return prf.Derive("prf", nil, n), nil
}
